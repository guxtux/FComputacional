\documentclass[12pt]{beamer}
\usepackage{../Estilos/BeamerFC}
\usepackage{../Estilos/ColoresLatex}
\input{../Preambulos/pre_codigo}
\input{../Preambulos/preambulo_Beamer_Dresden_seahorse}
\usefonttheme{serif}

\title{\large{Cálculo de raíces}}
\subtitle{Tema 2 - Operaciones matemáticas básicas}
\author{M. en C. Gustavo Contreras Mayén}
\date{}

\begin{document}
\maketitle

\section*{Contenido}
\frame{\tableofcontents[currentsection, hideallsubsections]}

\section{Bisección}
\frame{\tableofcontents[currentsection, hideothersubsections]}
\subsection{La variable \texttt{switch}}

% % \begin{frame}[fragile]
% % \frametitle{Algoritmo para el método de bisección}
% % 	\begin{lstlisting}
% %     for i in np.arange(n):
% %         x3 = 0.5*(x1 + x2); f3 = f(x3)
% %         if (switch == 0) and (abs(f3) > abs(f1)) \
% %                         and (abs(f3) > abs(f2)):
% %             return None
% %         if f3 == 0.0: return x3
% %         if f2*f3 < 0.0:
% %             x1 = x3; f1 = f3
% %         else:
% %             x2 =x3; f2 = f3
% %     return (x1 + x2)/2.0
% % 	\end{lstlisting}

% % \end{frame}
% % \begin{frame}
% % Haciendo que la variable \texttt{switch} = 1, se forza la rutina para comprobar si la magnitud de $f(x)$ disminuye con la reducción a la mitad de cada intervalo.
% % \end{frame}
% % \begin{frame}
% % Si no es así, algo anda mal (probablemente la \enquote{raíz} no es una raíz en absoluto, sino una singularidad) y se devuelve la \texttt{raíz} = \texttt{None}.
% % \\
% % \bigskip
% % Dado que esta característica no siempre es deseable, el valor predeterminado es \texttt{switch}=0.
% % \end{frame}

\begin{frame}
\frametitle{Revisión de la variable}
Veamos lo que hace la variable \texttt{switch}:
\\
\bigskip
\pause
Hasta el momento no nos hemos fijado en la magnitud de $f (x_{1})$ y $f (x_{2})$, sólo y en el signo del respectivo producto, pero ahora, tomamos en cuenta la magnitud tanto de los puntos evaluados en la función como del producto mismo.
\end{frame}
\begin{frame}
\frametitle{Revisión de la variable}
Del ejercicio:
\begin{align*}
x^{3} - 10 \; x^{2} + 5 = 0
\end{align*}
\pause
Sabemos que hay una raíz en el intervalo $[0.6, 0.8]$
\end{frame}
\begin{frame}
\frametitle{Valores en una tabla}
\begin{table}
\centering
\renewcommand{\arraystretch}{0.9}
\begin{tabular}{c | c | c | c | c | c }
$x_{1}$ & $x_{3}$ & $x_{2}$ & $f (x_{1})$ & $f (x_{3})$ & $f (x_{2})$ \\ \hline
$0.00000$ & $0.50000$ & $1.00000$ & $5.00000$ & $2.62500$	& $-4.00000$ \\ \hline
$0.50000$ & $0.75000$ & $1.00000$ & $2.62500$ & $-0.20312$	& $-4.00000$ \\ \hline
$0.50000$ & $0.62500$ & $0.75000$ & $2.62500$ & $1.33789$	& $-0.20312$ \\ \hline
$0.62500$ & $0.68750$ & $0.75000$ & $1.33789$ & $0.59839$	& $-0.20312$ \\ \hline
% $0.68750$ & $0.71875$ & $0.75000$ & $0.59839$ & $0.20529$	& $-0.20312$ \\ \hline
% $0.71875$ & $0.73438$ & $0.75000$ & $0.20529$ & $0.00299$	& $-0.20312$ \\ \hline
% $0.73438$ & $0.74219$ & $0.75000$ & $0.00299$ & $-0.09959$	& $-0.20312$ \\ \hline
% $0.73438$ & $0.73828$ & $0.74219$ & $0.00299$ & $-0.04819$	& $-0.09959$ \\ \hline
% $0.73438$ & $0.73633$ & $0.73828$ & $0.00299$ & $-0.02257$	& $-0.04819$ \\ \hline
% $0.73438$ & $0.73535$ & $0.73633$ & $0.00299$ & $-0.00978$	& $-0.02257$ \\ \hline
% $0.73438$ & $0.73486$ & $0.73535$ & $0.00299$ & $-0.00340$	& $-0.00978$ \\ \hline
% $0.73438$ & $0.73462$ & $0.73486$ & $0.00299$ & $-0.00020$	& $-0.00340$ \\ \hline
% $0.73438$ & $0.73450$ & $0.73462$ & $0.00299$ & $0.00139$	& $-0.00020$ \\ \hline
% $0.73450$ & $0.73456$ & $0.73462$ & $0.00139$ & $0.00059$	& $-0.00020$ \\ \hline
\end{tabular}
\end{table}
\begin{tikzpicture}[overlay]
    \uncover<1>{\draw[thick, red] (0, 2.5) rectangle (11.3, 3.3);}
    \uncover<2>{\draw[thick, blue, fill=blue, opacity=0.2] (7.4, 2.5) rectangle (11.3, 3.3);}
    \uncover<3>{\draw[thick, blue, fill=blue, opacity=0.2] (5.5, 1.8) rectangle (9.3, 2.4);}
    \uncover<4>{\draw[thick, blue, fill=blue, opacity=0.2] (7.4, 1.1) rectangle (11.3, 1.7);}
    \uncover<5>{\draw[thick, blue, fill=blue, opacity=0.2] (7.4, 0.3) rectangle (11.3, 1);}
\end{tikzpicture}
\end{frame}
\begin{frame}
\frametitle{Valores en una tabla}
\begin{table}
\centering
\renewcommand{\arraystretch}{0.9}
\begin{tabular}{c | c | c | c | c | c }
$x_{1}$ & $x_{3}$ & $x_{2}$ & $f (x_{1})$ & $f (x_{3})$ & $f (x_{2})$ \\ \hline
% $0.00000$ & $0.50000$ & $1.00000$ & $5.00000$ & $2.62500$	& $-4.00000$ \\ \hline
% $0.50000$ & $0.75000$ & $1.00000$ & $2.62500$ & $-0.20312$	& $-4.00000$ \\ \hline
% $0.50000$ & $0.62500$ & $0.75000$ & $2.62500$ & $1.33789$	& $-0.20312$ \\ \hline
% $0.62500$ & $0.68750$ & $0.75000$ & $1.33789$ & $0.59839$	& $-0.20312$ \\ \hline
% $0.68750$ & $0.71875$ & $0.75000$ & $0.59839$ & $0.20529$	& $-0.20312$ \\ \hline
% $0.71875$ & $0.73438$ & $0.75000$ & $0.20529$ & $0.00299$	& $-0.20312$ \\ \hline
% $0.73438$ & $0.74219$ & $0.75000$ & $0.00299$ & $-0.09959$	& $-0.20312$ \\ \hline
% $0.73438$ & $0.73828$ & $0.74219$ & $0.00299$ & $-0.04819$	& $-0.09959$ \\ \hline
% $0.73438$ & $0.73633$ & $0.73828$ & $0.00299$ & $-0.02257$	& $-0.04819$ \\ \hline
\ldots & \ldots & \ldots & \ldots & \ldots & \ldots \\ \hline 
$0.73438$ & $0.73535$ & $0.73633$ & $0.00299$ & $-0.00978$	& $-0.02257$ \\ \hline
$0.73438$ & $0.73486$ & $0.73535$ & $0.00299$ & $-0.00340$	& $-0.00978$ \\ \hline
$0.73438$ & $0.73462$ & $0.73486$ & $0.00299$ & $-0.00020$	& $-0.00340$ \\ \hline
$0.73438$ & $0.73450$ & $0.73462$ & $0.00299$ & $0.00139$	& $-0.00020$ \\ \hline
$0.73450$ & $0.73456$ & $0.73462$ & $0.00139$ & $0.00059$	& $-0.00020$ \\ \hline
\end{tabular}
\end{table}
\begin{tikzpicture}[overlay]
    \uncover<1>{\draw[thick, red] (0, 3.3) rectangle (11.3, 3.9);}
    \uncover<2>{\draw[thick, blue, fill=blue, opacity=0.2] (5.5, 3.3) rectangle (9.3, 3.9);}
    \uncover<3>{\draw[thick, blue, fill=blue, opacity=0.2] (5.5, 2.5) rectangle (9.3, 3.1);}
    \uncover<4>{\draw[thick, blue, fill=blue, opacity=0.2] (5.5, 1.8) rectangle (9.3, 2.3);}
    \uncover<5>{\draw[thick, blue, fill=blue, opacity=0.2] (5.5, 1.1) rectangle (9.3, 1.6);}
    \uncover<6>{\draw[thick, blue, fill=blue, opacity=0.2] (5.5, 0.4) rectangle (9.3, 1.0);}
\end{tikzpicture}
\end{frame}
    
% \begin{frame}[fragile]
% \frametitle{Revisando el código}
% Del código tenemos que:
% \pause
% \begin{verbatim}
% if (switch == 0) and (abs(f3) > abs(f1)) \ 
%                  and (abs(f3) > abs(f2)):
%     return None
% \end{verbatim}
% \end{frame}
% \begin{frame}[fragile]
% \frametitle{Valor de la expresión}
% \begin{table}
% \centering
% \renewcommand{\arraystretch}{0.9}
% \begin{tabular}{l | l | l | l | c}
% $x_{1}$ & $x_{2}$ & $f(x_{1})$ & $f(x_{2})$ & $f (x_{1}) f (x_{2})$ \\ \hline
% $0.0$ & $0.2$ & $5.0$ & $4.608$ & $23.04$ \\ \hline
% $0.2$ & $0.4$ & $4.608$ & $3.464$ & $15.9621$ \\ \hline
% \end{tabular}
% \end{table}    

% \begin{table}
%     \centering  
% \begin{tabular}{l  | l | l}
% $\abs{f3} > \abs{f1}$ & $\abs{f3} > \abs{f2}$ & Expresión \\ \hline
% \texttt{True} & \texttt{True} & True \\ \hline
% \end{tabular}
% \end{table}

% \begin{tikzpicture}[overlay]
%     \draw[thick, red] (1.7, 6) rectangle (9.5, 7);
% \end{tikzpicture}
% \end{frame}

\section{Newton-Raphson}
\frame{\tableofcontents[currentsection, hideothersubsections]}
\subsection{Definición}

\begin{frame}
\frametitle{Método de Newton-Raphson}
El método de Newton-Raphson es el algoritmo más conocido para encontrar raíces por una buena razón: es simple y rápido.
\\
\bigskip
\pause
El único detalle es que utiliza la derivada $\pderivada{f} (x)$ así como la función $ f(x)$. \pause Por tanto, en los problemas a resolver con este algoritmo, deberá de contemplarse que la derivada sea fácil de calcularse.
\end{frame}
\begin{frame}
\frametitle{Método de Newton-Raphson}
El método de Newton-Raphson (\funcionazul{MNR} se obtiene de la expansión en series de Taylor de $f (x)$ alrededor de $x$:
\pause
\begin{align*}
f (x_{i + 1})  = f (x_{i}) + \pderivada{f} (x_{i})(x_{i + 1} - x_{i}) +\order{x_{i + 1} - x_{i}}^{2}
\end{align*}
\end{frame}
\begin{frame}\frametitle{Método de Newton-Raphson}
Si $x_{i + 1}$ es una raíz de $f (x) = 0$, tenemos que:
\pause
\begin{align*}
0 = f (x_{i}) + \pderivada{f} (x_{i})(x_{i + 1} - x_{i}) + \order{x_{i + 1} - x_{i}}^{2}
\end{align*}
\pause
Suponiendo que $x_{i}$ está cerca de $x_{i + 1}$, podemos eliminar el último término de la ecuación y resolver para $x_{i+1}$, por lo que la fórmula de Newton-Raphson es:
\pause
\begin{align*}
x_{i+1} = x_{i} - \dfrac{f(x_{i})}{\pderivada{f} (x_{i})}
\end{align*}
\end{frame}
\begin{frame}
\frametitle{Error en el método}
Si $x$ representa el valor verdadero de la raíz, el error en $x_{i}$ es $E_{i} = x - x_{i}$.
\\
\bigskip
\pause
Se puede demostrar que si $x_{i+1}$ se calcula de la expresión del \funcionazul{MNR}, el error es:
\pause
\begin{align*}
E_{i+1} = - \dfrac{\sderivada{f} (x_{i})}{2 \, \pderivada{f} (x_{i})} \; E_{i}^{2}
\end{align*}
Lo que nos dice que el \funcionazul{MNR} converge de manera cuadrática, es decir, el error es el cuadrado del error del punto previo.
\end{frame}
\begin{frame}[fragile]
\frametitle{Representación gráfica}
Podemos interpretar que $x_{i+1}$ es el punto en donde la tangente de $f (x_{i})$ cruza el eje de las $x$:
\pause
\begin{center}
	\begin{tikzpicture}[font=\small, scale=0.8]
		\draw [->] (0,0) -- (7,0);
		\draw [<->] (0,-3) -- (0,3);
		\draw [red, thick] (1,3) .. controls (1.5,0.5) and (5,-2) .. (6.5,-2);
		\draw (1,-0.3) node {$x_{i}$};
		\draw (1,3.3) node {$f(x_{i})$};
		\draw [dashed] (1.2,0) -- (1.2,2.35);
		\draw (0.8,3.1) -- (2.35,-0.1);
		\draw [dashed] (2.3,0) -- (2.3,0.58);
		\draw (2.3,-0.3) node {$x_{i+1}$};
	\end{tikzpicture}
\end{center}
\end{frame}
\begin{frame}[fragile]
\frametitle{Criterio de convergencia}
El \funcionazul{MNR}, es sencillo: \pause se aplica la expresión para $x_{i + 1}$ iniciando con un valor $x_{0}$, hasta alcanzar un criterio de convergencia:
\pause
\begin{align*}
\abs{ x_{i+1} - x_{i} } < \varepsilon
\end{align*}
\end{frame}
\begin{frame}[fragile]
\frametitle{Algoritmo del método}
El algoritmo es el siguiente:
\pause
\setbeamercolor{item projected}{bg=lava,fg=white}
\setbeamertemplate{enumerate items}{%
\usebeamercolor[bg]{item projected}%
\raisebox{1.5pt}{\colorbox{bg}{\color{fg}\footnotesize\insertenumlabel}}%
}
\begin{enumerate}[<+->]
\item Sea $x$ un valor inicial para la raíz de $f (x) = 0$.
\item Calcular $\Delta x = - f (x)/\pderivada{f} (x)$.
\item Asignar $x \leftarrow x + \Delta x$ y se repiten los pasos 2-3, hasta alcanzar $\abs{ \Delta x } < \varepsilon$.
\end{enumerate}
\end{frame}
\begin{frame}[fragile]
\frametitle{Precaución con el \funcionazul{MNR}}
Aunque el \funcionazul{MNR} converge rápidamente cerca de la raíz, sus características globales de convergencia son pobres. 
\\
\bigskip
\pause
La razón es que la línea tangente no es siempre una aproximación aceptable de la función.
\end{frame}
\begin{frame}[fragile]
\frametitle{Precaución con el \funcionazul{MNR}}
\begin{center}
	\begin{tikzpicture}[font=\small, scale=0.8]
		\draw [->] (0,0) -- (4,0);
		\draw [<->] (0,-1) -- (0,3);
		\draw [red, thick] (1,3) .. controls (2,3) and (2.5,2) .. (3.5,-2);
		\draw (4.2,0) node {$x$};
		\draw (-0.5,2) node {$f (x)$};
		\draw (1.2,-0.2) node {$x_{0}$}; \pause
        \draw [fill=blue] (1.2,3) circle (0.05); \pause
        \draw [dashed] (1.2,0) -- (1.2,3); \pause
	    \draw [blue, ->] (1.2,3) -- (3.5,2.7);
	\end{tikzpicture}
\end{center}
\end{frame}
\begin{frame}[fragile]
\frametitle{Precaución con el \funcionazul{MNR}}
\begin{center}
\setbeamercovered{invisible}
	\begin{tikzpicture}%[decoration={
  %markings,% activar las marcas
  %mark= at position 2cm with{\arrow{stealth}}}]
		\draw [->] (0,0) -- (6,0);
		\draw [<->] (0,-2) -- (0,2);
		\draw [red, thick] (0.5,-2) .. controls (3,-1.9) and (3,1.9) .. (5.5,2);
		\draw (4.5,-0.3) node {$x_{0}$}; \pause
		\draw [dashed] (4.5,0) -- (4.5,1.69); \pause
		\draw [fill=blue] (4.5,1.7) circle (0.04); \pause
		\draw [blue, postaction={decorate}] (4.5,1.7) -- (1,0); \pause
		\draw (1,0.3) node {$x_{1}$}; \pause
		\draw [fill=blue] (1,0) circle (0.04);\pause
		\draw [dashed] (1,0) -- (1,-1.95); \pause
		\draw (1,-1.95) circle (0.04); \pause
		\draw [blue, postaction={decorate}] (1,-1.95) -- (5.8,0.1);
	\end{tikzpicture}
\end{center}
\end{frame}

\subsection{Ver. 1.0 algoritmo para el \texttt{MNR}}

\begin{frame}
\frametitle{Primera versión del algoritmo}
Esta versión del algoritmo del \funcionazul{MNR} requiere de un punto $x$ de aproximación a la raíz, así como la función $f$ y la derivada $df$ que se indican dentro del código.
\\
\bigskip
\pause
La versión 1.0 del \funcionazul{MNR} se debe de guardar en el módulo \funcionazul{moduloRaices}.
\end{frame}
\begin{frame}[fragile]
\frametitle{Primera versión del algoritmo}
\begin{lstlisting}[caption=Primera versión del MNR]
def newtonRaphson1(x, f, df, tol=1e-05):
    for i in range(50):
        dx = -f(x)/df(x)
        x = x + dx
        if abs(dx) < tol: return x, i
    print('Son demasiadas iteraciones\n')
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Ejercicio}
Con la versión 1.0 del \funcionazul{MNR} calcula la raíz positiva más pequeña de:
\begin{align*}
f (x) = x^{4} - 6.4 \, x^{3} + 6.45 \, x^{2} + 20.538 \, x - 31.752
\end{align*}
\pause
Tip: Para proporcionar el punto $x$ próximo a la función hay que graficar la misma, para que por inspección visual se indique el valor de $x$.
\end{frame}
\begin{frame}
\frametitle{Gráfica de la función $f (x)$}
\begin{figure}
    \centering
    \includegraphics[scale=0.55]{Imagenes/raices_03_MNR_01.eps}
\end{figure}
\end{frame}
\begin{frame}
\frametitle{Eligiendo el punto $x$}
Revisando la gráfica anterior, con un acercamiento al trazo de la curva donde $y = 0$, \pause vemos que la raíz está cerca de $2.1$, \pause por lo que proponemos que $x = 2.0$
\end{frame}
\begin{frame}[allowframebreaks, fragile]
\frametitle{Código con la ver. 1.0}
\begin{lstlisting}[caption=Código para resolver el ejercicio 1]
from moduloRaices import newtonRaphson1
import numpy as np

def f(x): return x**4 - 6.4*x**3 + 6.45*x**2 + 20.538*x - 31.752
def df(x): return 4.0*x**3 - 19.2*x**2 + 12.9*x + 20.538

raiz, numIter = newtonRaphson1(2.0, f, df)

print('La raíz es = {0:1.5f}'.format(raiz))
print('Número de iteraciones realizadas = {0:}'.format(numIter))

x = np.linspace(0, 5)

# Aquí va la rutina de graficación
# No olvides llamar a las correspondientes librerías
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Gráfica con la raíz calculada}
\begin{figure}
    \centering
    \includegraphics[scale=0.55]{Imagenes/raices_03_MNR_02.eps}
\end{figure}
\end{frame}
\begin{frame}
\frametitle{Error relativo}
Usando el valor exacto de la raíz: $2.1$, el error relativo ocupando el \funcionazul{MNR} es de $\num{4.7619d-6}$.
\end{frame}

\subsection{Ver. 2.0 del \texttt{MNR}}

\begin{frame}
\frametitle{Algoritmo para el \funcionazul{MNR}}
La siguiente versión 2. 0 del algoritmo para el \funcionazul{MNR} supone que la raíz a calcularse, está en el intervalo $[a, b]$.
\end{frame}
\begin{frame}
\frametitle{Algoritmo para el \funcionazul{MNR}}
El punto medio del intervalo se utiliza como aproximación inicial de la raíz. \pause Los extremos del intervalo se actualizan luego de cada iteración.
\\
\bigskip
\pause
Si una iteración del \funcionazul{MNR} no se mantiene dentro del intervalo, se descarta y se reemplaza con el método de bisección.
\end{frame}
\begin{frame}
\frametitle{Algoritmo para el \funcionazul{MNR}}
Ya que el \funcionazul{MNR} requiere de la función $ f(x)$, así como su derivada, (denotadas por $f$ y $df$), \pause éstas deben ser proporcionadas por el usuario.
\\
\bigskip
\pause
La nueva versión debe de quedar dentro del \funcionazul{moduloRaices}.
\end{frame}
\begin{frame}[plain, allowframebreaks, fragile]
\frametitle{Algoritmo para el \funcionazul{MNR}}
\begin{lstlisting}[caption=Código para la segunda versión del MNR]
def newtonRaphson2(f, df, a, b, tol = 1.0e-9):
    fa = f(a)
    if fa == 0.0: return a

    fb = f(b)
    if f(b) == 0.0: return b

    if fa*fb > 0.0: print('La raiz no esta en el intervalo')
    x = 0.5 * (a + b)

    for i in range(30):
        fx = f(x)
        if abs(fx) < tol: return x

        if fa*fx < 0.0:
            b = x
        else:
            a = x; fa = fx

        dfx = df(x)
        
        try: dx = -fx/dfx
        except ZeroDivisionError: dx = b - a
        x =  x + dx
        
        # Si el resultado esta fuera del intervalo
        # se usa el metodo de biseccion
        if (b - x)*(x - a) < 0.0:
            dx = 0.5*(b-a)
            x = a + dx
        
        if abs(dx) < tol*max(abs(b), 1.0): return x
    
    print('Son demasiadas iteraciones')
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Ejercicio con la versión 2}
Usando la ver. 2.0 del algoritmo \funcionazul{MNR}, calcula las dos raíces de la función:
\begin{align*}
\sin \: x + 3 \: \cos \: x - 2 = 0
\end{align*}
en el intervalo $(-2, 2)$
\end{frame}
\begin{frame}
\frametitle{Primer paso: graficar la función}
\begin{figure}
	\centering
    \includegraphics[scale=0.55]{Imagenes/raices_03_MNR_03.eps}
\end{figure}
\end{frame}
\begin{frame}[fragile]
\frametitle{Intervalos de las raíces}
Con el método de incrementos sucesivos, estimamos cada intervalo donde se encuentran las raíces de la función.
\end{frame}
\begin{frame}[plain, fragile]
\frametitle{Intervalos de las raíces}
\begin{lstlisting}[caption=Intervalos para las raíces]
inicio, final, dx = -2., 2. , 0.01

a1, b1 = buscaraiz(f, inicio, final, 0.1)
print('Una raiz esta en el intervalo ({0:1.4f}, {1:1.4f})'.format(a1, b1))

inicio = b1

a2, b2 = buscaraiz(f, inicio, final, 0.1)
print('Otra raiz esta en el intervalo ({0:1.4f}, {1:1.4f})'.format(a1, b2))
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Los intervalos}
El resultado que nos devuelve la función de incrementos sucesivos es:
\pause
\begin{verbatim}
Una raíz está en [ -0.6 , -0.5 ]
Una raíz está en [ 1.2 , 1.3 ]
\end{verbatim}
\end{frame}
\begin{frame}[allowframebreaks, fragile]
\frametitle{Código completo}
\begin{lstlisting}[caption=Código completo para el ejercicio 1]
from ModuloRaices import buscaraiz, newtonRaphson
import matplotlib.pyplot as plt
import numpy as np

def f(x): return np.sin(x) + 3 * np.cos(x) - 2

def df(x): return np.cos(x) - 3 * np.sin(x)

intervalo1 = []
intervalo2 = []

inicio, final, dx = -2., 2. , 0.01

# Se determina el intervalo para la primera raíz
a1, b1 = buscaraiz(f, inicio, final, 0.1)
print('Una raiz esta en el intervalo ({0:1.4f}, {1:1.4f})'.format(a1, b1))
intervalo1.append(a1)
intervalo1.append(b1)

# Se determina el intervalo para la segunda raíz
inicio = b1
a2, b2 = buscaraiz(f, inicio, final, 0.1)
print('Otra raiz esta en el intervalo ({0:1.4f}, {1:1.4f})'.format(a2, b2))
intervalo2.append(a2)
intervalo2.append(b2)

# Se ocupa la ver. 2.0 del algoritmo MNR
raiz1 = newtonRaphson2(f, df, intervalo1[0], intervalo1[-1], 1.e-4)
print('La primera raiz en el intervalo ({0:1.4f}, {1:1.4f}) = '.format(intervalo1[0], intervalo1[-1], raiz1))

# Se ocupa la ver. 2.0 del algoritmo MNR
raiz2 = newtonRaphson2(f, df, intervalo2[0], intervalo2[-1], 1.e-4)
print('La segunda raiz en el intervalo ({0:1.4f}, {1:1.4f}) = '.format(intervalo2[0], intervalo2[-1], raiz2))

x = np.linspace(-2, 2)

# Rutina de graficacion
plot1 = plt.figure(1)
plt.plot(x, f(x))

plot2 = plt.figure(2)
plt.plot(x, f(x), color='g')
plt.plot(raiz1, 0, 'ro', label='Raiz 1 = ' + str(round(raiz1, 3)))
plt.plot(raiz2, 0, 'bo', label='Raiz 2 = ' + str(round(raiz2, 3)))

plt.show()
\end{lstlisting}    
\end{frame}
\begin{frame}
\frametitle{Solución con el valor de las dos raíces}
\begin{figure}
	\centering
    \includegraphics[scale=0.55]{Imagenes/raices_03_MNR_04.eps}
\end{figure}
\end{frame}
% \begin{frame}
% \frametitle{Ejercicio}
% Encontrar la raíz positiva más pequeña de
% \[ f(x) = x^{4} - 6.4 \: x^{3} + 6.45 \: x^{2} + 20.538 \: x - 31.752\]
% Como en los ejercicios anteriores, es buena idea generar una gráfica de la función.
% \end{frame}
% \begin{frame}
% \frametitle{Gráfica del ejercicio}
% \begin{figure}
% 	\centering
% 	\visible<2-> {\includegraphics[scale=0.5]{Imagenes/raices08.eps}}
% \end{figure}
% \end{frame}
% \begin{frame}
% \frametitle{Caso particular para esta función}
% Al realizar un poco de álgebra, nos encontramos con lo siguiente:
% \[ 0.002 (x - 4.) (5. x + 9.) (10. x - 21.)^{2} \]
% La función tiene dos raíces reales y una de multiplicidad $2$.
% \end{frame}
% \begin{frame}
% \frametitle{Ajuste al código de NR}
% Como el método de NR se basa en detectar el cambio de signo en la función, en este caso, para una raíz con multiplicidad $2$, haremos un ajuste al código del método.
% \end{frame} 	
% \begin{frame}[allowframebreaks,plain, fragile]
% \frametitle{Ejercicio}
% \begin{lstlisting}[caption=Código para el ejercicio, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]
% def f(x): return x**4 - 6.4*x**3 + 6.45*x**2 + 20.538*x - 31.752
% def df(x): return 4.0*x**3 - 19.2*x**2 + 12.9*x + 20.538

% def newtonRaphson(x,tol=1e-09):
%     for i in range(30):
%         dx = -f(x)/df(x)
%         x = x + dx
%         if abs(dx) < tol: return x,i
%     print 'Son demasiadas iteraciones\n'

% raiz,numIter = newtonRaphson(2.0)

% print 'Raiz =',raiz
% print 'Numero de iteraciones =',numIter
% \end{lstlisting}
% \end{frame}
% \begin{frame}
% \frametitle{Convergencia del método}
% Se puede demostrar que la convergencia del método NR cerca de una raíz con multiplicidad es linear, más que cuadrática.
% \\
% \bigskip
% \pause
% La convergencia de una raíz múltiple se puede acelerar al cambiar la fórmula de NR.
% \end{frame}
% \begin{frame}
% \frametitle{Ajuste a la función NR}
% Se ajusta de la forma
% \[ x_{i + 1} = x_{i} - m \; \dfrac{f(x_{i})}{f^{\prime}(x_{i})} \]
% donde $m$ es la multiplicidad de la raíz (en el ejemplo, $m = 2$). Después de hacer los ajustes, el resultado se obtiene en $5$ iteraciones.
% \end{frame}
% \begin{frame}
% \frametitle{Solución del ejercicio}
% \begin{figure}
% 	\centering
% 	\includegraphics[scale=0.5]{Imagenes/Raiz_NR_02.eps}
% \end{figure}
% \end{frame}

\subsection{Ejercicios a cuenta}

\begin{frame}
\frametitle{Resuelve con el \funcionazul{MNR}}
\setbeamercolor{item projected}{bg=armygreen,fg=white}
\setbeamertemplate{enumerate items}{%
\usebeamercolor[bg]{item projected}%
\raisebox{1.5pt}{\colorbox{bg}{\color{fg}\footnotesize\insertenumlabel}}%
}
\begin{enumerate}[<+->]
\item Encuentra las raíces de $x \, \sin x + 3 \, \cos x - x = 0$ en el intervalo $(-6, 6)$ \\
\item Calcula todas las raíces reales de $x^{4} + 0.9 \, x^{3} - 2.3 \, x^{2} + 3.6 \, x - 25.2 = 0$. \\
\item Calcula todas las raíces reales de $x^{4} + 2 \, x^{3} - 7 \, x^{2} + 3 = 0$. \\
\item Calcula todas las raíces de $\sin x - 0.1 \, x = 0$.
\end{enumerate}
\end{frame}

\section{Falsa posición}
\frame{\tableofcontents[currentsection, hideothersubsections]}
\subsection{Definición}

\begin{frame}
\frametitle{Método de la falsa posición}
Este método es parecido al de bisección, ya que el intervalo que contiene a la raíz se va reduciendo.
\\
\bigskip
\pause
En vez de bisectar de manera monótona el intervalo, se utiliza una interpolación lineal ajustada a dos puntos extremos para encontrar la aproximación de la raíz.
\end{frame}
\begin{frame}
\frametitle{Usando una interpolación lineal}
La función está bien aproximada por la interpolación lineal, con lo que las raíces tendrán una buena precisión; la iteración convergerá más rápido que como ocurre con el método de bisección.
\end{frame}
\begin{frame}
\frametitle{Ecuación de la recta}
Dado un intervalo $[a, c]$ que contenga a la raíz, la función lineal que pasa por $(a, f(a))$ y $(c, f(c))$ se escribe como:
\pause
\begin{align*}
y = f (a) + \dfrac{f (c) - f (a)}{c - a} \: (x - a)
\end{align*}
\pause
de donde se despeja $x$:
\pause
\begin{align*}
x = a + \dfrac{c - a}{f (c) - f (a)} \: \big[ y - f (a)\big]
\end{align*}
\end{frame}
\begin{frame}
\frametitle{Calculando el nuevo punto}
La coordenada $x$ en donde la línea intersecta al eje $x$ se determina al hacer $y = 0$ en la ecuación anterior, por tanto:
\pause
\begin{align*}
b = a - \dfrac{c - a}{f (c) - f (a)} \: f(a) = \dfrac{a \: f (c) - c \: f (a)}{f (c)-f (a)}
\end{align*}
Después de encontrar $b$, el intervalo $[a, c]$ se divide en $[a, b]$ y $[b, c]$.
\end{frame}
\begin{frame}
\frametitle{Revisando el producto de la función evaluada}
Si $f (a) * f (b) \leq 0$, la raíz se encuentra en $[a, b]$; \pause en caso contrario, está en $[b, c]$. 
\\
\bigskip
\pause
Los extremos del nuevo intervalo que contiene a la raíz se renombran para el siguiente paso como $a$ y $c$. \pause El procedimiento de interpolación se repite hasta que las raíces estimadas convergen.
\end{frame}
\begin{frame}[fragile]
\frametitle{Método de la falsa posición}
\begin{center}
\begin{tikzpicture}[font=\small]
    \draw [->] (0,0) -- (7,0);
    \draw [<->](0,-3) -- (0,3);
    \draw [red, thick] (1,3) .. controls (1.5,0.5) and (5,-2) .. (6.5,-2);
    \draw (1,-0.3) node {$a$};
    \draw (0.7, 2.4) node {$f(a)$};
    \draw (6,0.3) node {$c$};
    \draw (6.3, -2.4) node {$f(c)$};
    \draw [dashed] (1.2,0) -- (1.2,2.35);
    \draw [dashed] (6.3,0) -- (6.3,-1.98);\pause
    \draw (1.2,2.35) -- (6.3,-1.98);
    \draw  (3,3) node {1a. interpolación};
    \draw [->] (3,2.6) -- (2,2);\pause
    \draw  (5,1) node {1a. aproximación};
    \draw [->] (5,0.6) -- (4.1,0.1);
    \draw (4,0.3) node {$b_{1}$};
    \draw (4, -1.3) node {$f(b_{1})$};
    \draw [dashed] (4,0) -- (4,-0.9);
\end{tikzpicture}
\end{center}
\end{frame}
\begin{frame}[fragile]
\frametitle{Método de la falsa posición}
\begin{figure}
\centering
\begin{tikzpicture}[font=\small]
    \draw [->] (0,0) -- (7,0);
    \draw [<->] (0,-3) -- (0,3);
    \draw [red, thick] (1,3) .. controls (1.5,0.5) and (5,-2) .. (6.5,-2);
    \draw (1,-0.3) node {$a$};
    \draw (0.7, 2.4) node {$f(a)$};
    \draw (4,0.3) node {$c$};
    \draw (4, -1.3) node {$f(c)$};
    \draw [dashed] (4,0) -- (4,-0.9);
    \draw [dashed] (1.2,0) -- (1.2,2.35);\pause
    \draw (1.2,2.35) -- (4,-0.9);
    \draw  (4,2) node {2a. interpolación};
    \draw [->] (4,1.6) -- (2.5,1);\pause
    \draw [dashed] (3.25,0) -- (3.25,-0.43);
    \draw (3.2, 0.3) node {$b_{2}$};
    \draw (3, -0.75) node {$f(b_{2})$};
    \draw  (6,1) node {2a. aproximación};
    \draw [->] (5.5,0.8) -- (3.3,0.1);
\end{tikzpicture}
\caption{Se renombran los extremos y se realiza la segunda aproximación lineal.}
\end{figure}
\end{frame}
\begin{frame}
\frametitle{Desventaja en el  método}
\textcolor{red}{La desventaja de este método es que aparecen extremos fijos}: \pause uno de los extremos de la sucesión de intervalos no se mueve del punto original, por lo que las aproximaciones a la raíz, denotadas por $b_{1}$, $b_{2}$, $b_{3}$, etc. convergen a la raíz exacta solamente por un lado.
\end{frame}
\begin{frame}
\frametitle{Presencia de extremos fijos}
Los extremos fijos no son deseables debido a que hacen más lenta la convergencia, en particular cuando el intervalo es grande o cuando la función se desvía de manera significativa de una línea recta en el intervalo.
\\
\bigskip
\pause
\textbf{¿Qué podemos hacer al respecto?}
\end{frame}

\section{Falsa posición modificado}
\frame{\tableofcontents[currentsection, hideothersubsections]}
\subsection{Construyendo el método}

\begin{frame}
\frametitle{Método de la falsa posición modificado}
En este método, el valor de $f$ en un punto fijo se divide a la mitad si este punto se ha repetido más de dos veces.
\\
\bigskip
\pause
El extremo que se repite se llama extremo fijo. \pause La excepción para esta regla es que para $i = 2$, el valor de $f$ en un extremo se divide entre $2$ de inmediato si no se mueve.
\end{frame}
\begin{frame}[fragile]
\frametitle{Método de falsa posición modificado}
\begin{figure}
\centering
\begin{tikzpicture}[font=\small]
    \draw [->] (0,0) -- (7,0);
    \draw [<->](0,-3) -- (0,3);
    \draw [red, thick] (1,3) .. controls (1.5,0.5) and (5,-2) .. (6.5,-2);
    \draw (1,-0.3) node {$a$};
    \draw (0.7, 2.4) node {$f (a)$};
    \draw (6,0.3) node {$c$};
    \draw (6.3, -2.4) node {$f (c)$};
    \draw [dashed] (1.2,0) -- (1.2,2.35);
    \draw [dashed] (6.3,0) -- (6.3,-1.98);\pause
    
    \draw (1.2,2.35) -- (6.3,-1.98);
    \draw  (3,3) node {1a. interpolación};
    \draw [->] (3,2.6) -- (2,2);\pause
    \draw  (5,1) node {1a. aproximación};
    \draw [->] (5,0.6) -- (4.1,0.1);
    \draw (4,0.3) node {$b_{1}$};
    \draw (4, -1.3) node {$f (b_{1})$};
    \draw [dashed] (4,0) -- (4,-0.9);
	\end{tikzpicture}
\end{figure}
\end{frame}
\begin{frame}[fragile]
\frametitle{Método de la falsa posición modificado}
\begin{figure}
\centering
\begin{tikzpicture}[font=\small]
    \draw [->] (0,0) -- (7,0);
    \draw [<->] (0,-3) -- (0,3);
    \draw [red, thick] (1,3) .. controls (1.5,0.5) and (5,-2) .. (6.5,-2);
    \draw (1,-0.3) node {$a$};
    \draw (0.7, 2.4) node {$f(a)$};
    \draw (4,0.3) node {$c$};
    \draw (4, -1.3) node {$f(c)$};
    \draw [dashed] (4,0) -- (4,-0.9);
    \draw [dashed] (1.2,0) -- (1.2,2.35);\pause
    \draw  (4,2) node {2a. interpolación};
    \draw [->] (4,1.6) -- (1.8,1);
    \draw (1.2,1.3) -- (4,-0.9);
    \draw (0.8, 1.3) node {$\frac{f (a)}{2}$};
    \pause
    \draw [dashed] (3.25,0) -- (3.25,-0.43);
    \draw (3.2, 0.3) node {$b_{2}$};
    \draw (3, -0.75) node {$f (b_{2})$};
    \draw  (6,1) node {2a. aproximación};
    \draw [->] (5.5,0.8) -- (3.3,0.1);
\end{tikzpicture}
\caption{Se evitan los extremos fijos de tal manera que se acelera la convergencia.}
\end{figure}
\end{frame}

\section{La secante}
\frame{\tableofcontents[currentsection, hideothersubsections]}
\subsection{Construcción del método}

\begin{frame}
\frametitle{Método de la secante}
A diferencia del método de Newton, el valor de $\pderivada{f}$ se aproxima utilizando dos valores de iteraciones consecutivas de $f$.
\\
\bigskip
\pause
Con lo que se elimina la necesidad de evaluar tanto a $f$ como a $\pderivada{f}$ en cada iteración.
\end{frame}
\begin{frame}
\frametitle{Aproximaciones sucesivas}
Las aproximaciones sucesivas para la raíz en el método de la secante están dadas por:
\pause
\begin{align*}
x_{n} = x_{n - 1} - y_{n - 1} \, \dfrac{x_{n - 1} - x_{n - 2}}{y_{n - 1}- y_{n - 2}}, \hspace{1cm} n = 2, 3, \ldots
\end{align*}
donde $x_{0}$ y $x_{1}$ son dos suposiciones iniciales para comenzar la iteración.
\end{frame}
\begin{frame}[fragile]
\frametitle{Método de la secante}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[font=\small]
    \draw [->] (0,0) -- (7.5,0);
    \draw [->] (0,0) -- (0,4);
    \draw [red, thick](7,3.5) .. controls (6.3,2) and (4.5,0.3) .. (1,0);
    \draw [dashed] (6.8,3.1) -- (6.8,0);
    \draw (6.6,-0.3) node {$x_{0}$};
    \draw (6.6, 3.3) node {$f_{0}$};
    \draw [dashed] (5.5,1.65) -- (5.5,0);
    \draw (5.25,-0.3) node {$x_{1}$};
    \draw (5.25, 1.8) node {$f_{1}$};
    \draw (6.8,3.1) -- (4.1,0);\pause
    \draw (4,-0.3) node {$x_{2}$};
    \draw [dashed] (4.1,0) -- (4.1,0.8);
    \draw (3.9, 1) node {$f_{2}$};\pause
    \draw (5.5,1.65) -- (2.9,0);
    \draw (2.8,-0.3) node {$x_{3}$};
\end{tikzpicture}
\end{center}
\end{frame}
\begin{frame}
\frametitle{Atento aviso}
En las técnicas de falsa posición, falsa posición modificada y el método de la secante, no hemos presentado como tal un código en \python{} que nos devuelva las raíces, por lo que tendrás que proponer un código para cada una de las técnicas.
\\
\medskip
Ese código lo vas a utilizar par resolver los problemas y ejercicios del examen.
\end{frame}

\subsection{Ejercicios a cuenta}

\begin{frame}
\frametitle{Ejercicio a cuenta}
% Ref. Turner (2018) pág. 172
La función:
\begin{align*}
3 \, x^{3} - 5 \, x^{2} -  4 \, x + 4 = 0
\end{align*}
tiene una raíz cerca de $x = 0.7$.
\setbeamercolor{item projected}{bg=ao,fg=white}
\setbeamertemplate{enumerate items}{%
\usebeamercolor[bg]{item projected}%
\raisebox{1.5pt}{\colorbox{bg}{\color{fg}\footnotesize\insertenumlabel}}%
}
\begin{enumerate}[<+->]
\item Implementa el método de la secante para obtener la solución
\item Compara los resultados con el método de Newton-Raphson. 
\end{enumerate}
\end{frame}
\begin{frame}
\frametitle{Ejercicio a cuenta}
Utiliza el método de la secante para obtener la raíz de:
\begin{align*}
e^{x} - 3 \, x -1 = 0
\end{align*}
en el intervalo $[1, 3]$, usando una tolerancia de $\num{d-10}$.
\end{frame}

\section{Resolviendo con \texttt{python}}
\frame[allowframebreaks]{\tableofcontents[currentsection, hideothersubsections]}
\subsection{Bisección}

\begin{frame}
\frametitle{Obteniendo las raíces con funciones de \python}
Como hemos revisando en temas anteriores, luego de la construcción de diferentes algoritmos para el cálculo de raíces, ahora veremos tres métodos distintos para realizar la misma tarea, pero con funciones de las librerías de \python.
\end{frame}
\begin{frame}
\frametitle{Recomendación}
El que tengamos disponibles funciones de \python, no quiere decir que las respuestas a los ejercicios de tarea o del examen, se entreguen usando estas funciones.
\\
\bigskip
\pause
Se podrán utilizar para verificar que su código inicial está devolviendo el resultado esperado.
\end{frame}

\subsection{Optimize.bisect}

\begin{frame}
\frametitle{De la librería \texttt{scipy}}
Dentro de la librería \funcionazul{scipy} tenemos un módulo llamado \funcionazul{optimize}, que a su vez contiene la función \funcionazul{bisect}.
\end{frame}
\begin{frame}[fragile]
\frametitle{La función \texttt{bisect}}
La función \funcionazul{bisect} requiere de al menos tres argumentos:
\pause
\begin{verbatim}
optimize.bisect(f, a, b)
\end{verbatim}
\pause
\setbeamercolor{item projected}{bg=armygreen=,fg=beige}
\setbeamertemplate{enumerate items}{%
\usebeamercolor[bg]{item projected}%
\raisebox{1.5pt}{\colorbox{bg}{\color{fg}\footnotesize\insertenumlabel}}%
}
\begin{enumerate}[<+->]
\item $f$ es la función en la que se desea obtener la raíz, se espera que sea una función continua.
\item $a$ es el valor inicial del intervalo.
\item $b$ es el valor final del intervalo.
\item Debe de garantizarse que $f (a)$ y $f (b)$ tengan signos contrarios.
\end{enumerate}
\end{frame}
\begin{frame}
\frametitle{La respuesta obtenida}
Esta función devuelve la raíz de la función $f$ en el intervalo $(a, b)$ indicado.
\\
\bigskip
\pause
Veamos su uso en el siguiente ejemplo:
\end{frame}
\begin{frame}
\frametitle{Ejercicio}
Calcula las raíces de:
\begin{align*}
x^{2} - 1 = 0
\end{align*}
en el intervalo $[-2, 2]$. Ocupa la función \funcionazul{bisect}.
\end{frame}
\begin{frame}
\frametitle{Preparando la respuesta}
Como ya sabemos, el primer paso es obtener una gráfica de la función en el intervalo que se nos indica.
\end{frame}
\begin{frame}
\frametitle{Gráfica de la función}
\begin{figure}
    \centering
    \includegraphics[scale=0.55]{Imagenes/raices_scipy_bisect_01.eps}
\end{figure}
\end{frame}
\begin{frame}[allowframebreaks, fragile]
\frametitle{Código para resolver el ejercicio}
\begin{lstlisting}[caption=Código para usar optimize.bisect]
from moduloRaices import buscaraiz
from scipy import optimize
import numpy as np

def f(x):
    return (x**2 - 1)

a, b, dx = -2., 2., 0.1

intervalo1 = []
intervalo2 = []
raices = []

inicio = a
final = 0.

a1, b1 = buscaraiz(f, inicio, final, dx)

inicio = final
final = b
a2, b2 = buscaraiz(f, inicio, final, dx)

raiz1 = optimize.bisect(f, a1, b1)
raiz2 = optimize.bisect(f, a2, b2)

print('La raíz está en x = {0:1.6f}'.format(raiz1))
print('La raíz está en x = {0:1.6f}'.format(raiz2))

# Completa la rutina de graficación
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Las raíces del ejercicio}
\begin{figure}
    \centering
    \includegraphics[scale=0.55]{Imagenes/raices_scipy_bisect_02.eps}
\end{figure}
\end{frame}

\subsection{Newton-Raphson}

\begin{frame}
\frametitle{El \funcionazul{MNR}}
Dentro del módulo \funcionazul{optimize} se tiene la función  \funcionazul{newton}, que implementa el método de Newton-Raphson que desarrollamos previamente.
\end{frame}

\subsection{\texttt{optimize.newton}}

\begin{frame}[fragile]
\frametitle{Parámetros de \funcionazul{newton}}
Los parámetros mínimos que requiere la función son los siguientes:
\pause
\begin{verbatim}
newton(f, x0, fprime=None)
\end{verbatim}
\pause
Donde:
\setbeamercolor{item projected}{bg=beige,fg=black}
\setbeamertemplate{enumerate items}{%
\usebeamercolor[bg]{item projected}%
\raisebox{1.5pt}{\colorbox{bg}{\color{fg}\footnotesize\insertenumlabel}}%
}
\begin{enumerate}[<+->]
\item $f$ es la función en donde se desea obtener la raíz.
\item $x0$ es el punto de estimación cercano a la raíz.
\item \texttt{fprime} es la derivada de la función. Si no se indica, se utiliza el método de la secante.
\end{enumerate}
\end{frame}
\begin{frame}
\frametitle{La respuesta que devuelve}
Esta función \funcionazul{newton} devuelve el valor de la raíz cuando se indica la función \texttt{f} y el punto \texttt{x0} estimado cercano a la raíz.
\\
\bigskip
\pause
Hagamos un ejercicio para ver su implementación.
\end{frame}
\begin{frame}
\frametitle{Ejercicio a resolver}
Con la función \funcionazul{optimize.newton} calcula la raíz de:
\begin{align*}
y (x) = x + 2 \, \cos x = 0
\end{align*}
\end{frame}
\begin{frame}
\frametitle{Graficando la función}
Como primer paso hay que graficar la función para tener una idea de su comportamiento, así podemos estimar un intervalo en donde se encuentre la raíz (o raíces).
\end{frame}
\begin{frame}
\frametitle{Gráfica de $f(x)$}
\begin{figure}
    \centering
    \includegraphics[scale=0.55]{Imagenes/raices_scipy_newton_01.eps}
\end{figure}
\end{frame}
\begin{frame}
\frametitle{Intervalo de trabajo}
De la gráfica encontramos que la raíz está cerca de $x_{0} = 2$, por lo que podremos utilizar este valor en los parámetros de la función \funcionazul{optimize.newton}.
\end{frame}
\begin{frame}[allowframebreaks, fragile]
\frametitle{Código para el ejercicio}
\begin{lstlisting}[caption=Código para resolver con optimize.newton]
import scipy.optimize
import numpy as np

def f(x):
    y = x + 2 * np.cos(x)
    return y

raiz= scipy.optimize.newton(f,  2, fprime=lambda x: 1 - 2 * np.sin(x))

print('La raíz de la función es = {0:1.5f}'.format(raiz))

x = np.linspace(-5, 5)

# Aqui va la rutina de graficacion
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Gráfica con la raíz obtenida}
\begin{figure}
    \centering
    \includegraphics[scale=0.55]{Imagenes/raices_scipy_newton_02.eps}
\end{figure}
\end{frame}

\subsection{\texttt{numpy.roots}}

\begin{frame}
\frametitle{Ocupando el módulo \texttt{numpy}}
Dentro de la librería \funcionazul{numpy} tenemos disponible la función \funcionazul{roots} para calcular la(s) raíz(ces) de \textcolor{armygreen}{un polinomio}.
\end{frame}
\begin{frame}[fragile]
\frametitle{Parámetros a ocupar}
La función \funcionazul{roots} requiere de:
\begin{verbatim}
np.roots(p)
\end{verbatim}
Donde $p$ es un arreglo con los coeficientes del polinomio. \pause Recuerda que ya vimos la manera de constuir un polinomio con \funcionazul{numpy}.
\end{frame}
\begin{frame}
\frametitle{Lo que devuelve}
Lo que devuelve la función \funcionazul{roots} es un arreglo con las raíces del polinomio.
\end{frame}
\begin{frame}
\frametitle{Ejercicio}
Con la función \funcionazul{np.roots} calcula las raíces del polinomio:
\pause
\begin{align*}
x^{3} - 10 \, x^{2} + 5 = 0
\end{align*}
Para facilitar el trabajo hay que ocupar las correspondientes funciones de \funcionazul{numpy} para crear el polninomio y evaluarlo.
\end{frame}
\begin{frame}
\frametitle{Gráfica inicial del polinomio}
\begin{figure}
    \centering
    \includegraphics[scale=0.55]{Imagenes/raices_numpy_roots_01.eps}
\end{figure}
\end{frame}
\begin{frame}[allowframebreaks, fragile]
\frametitle{Código a utilizar}
\begin{lstlisting}[caption=Código completo para resolver el ejercicio]
import numpy as np

# Creamos un polinomio a partir de los coeficientes
# polinomio = x^3 - 10 x^2 + 5
coeficientes = [1., -10, 0, 5]   

# Creamos un array dimensional
x = np.arange(-4, 11, .02)

#  Evaluamos el polinomio en x mediante polyval.
y = np.polyval(coeficientes, x)

# Calculamos las raices del polinomio
raices = np.roots(coeficientes)

# Evaluamos el polinomio en las raices
s = np.polyval(coeficientes, raices)
# Los valores que se presentan,
# para fines prácticos, son cero.
print(s)

print("Las tres raíces son: \n x0 = {0:1.3f},\n x1 = {1:1.3f},\n x2 = {2:1.3f}".format(raices[-1], raices[-2], raices[-3]))

# Completa la rutina de graficación
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Sobre el arreglo de la raíces}
Como observaste en el código anterior, se ha hecho un ordenamiento de las raíces de manera creciente, es decir, se presenta del valor más pequeño al más grande.
\\
\bigskip
\pause
No hay garantía de que \funcionazul{roots} nos devuelva un arreglo ordenado, por lo que hay que revisar con cuidado los valores.
\end{frame}
\begin{frame}
\frametitle{Gráfica con las raíces}
\begin{figure}
    \centering
    \includegraphics[scale=0.55]{Imagenes/raices_numpy_roots_02.eps}
\end{figure}
\end{frame}
\end{document}